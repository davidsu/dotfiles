#!/usr/bin/env node
const { spawn, exec, execSync } = require('child_process')
const  fetch  = require('node-fetch')
process.env.NOT_GREEDY = true
const { openChromeOnDebuggerUrl } = require('./debugger')

//todo use yargs and clean up this mess
const args = process.argv.splice(2)
const isInspect = arg => /--inspect/.test(arg)
const inspectBrk = args.find(isInspect) || ''
const timeout = inspectBrk ? '--testTimeout=600000': ''
const otherArgs = inspectBrk ? args.filter(a => !isInspect(a)) : args
const spawnArgs = [inspectBrk, '../../node_modules/.bin/jest', timeout, ...otherArgs].filter(a => a) 
if(inspectBrk) {
    // automatic kill application holding my debugging port
    const port = Number(inspectBrk.split('=')[1]) || 9229
    try {
        execSync(`kill $(lsof -i tcp:${port} -t)`, console.log)
    } catch(e) {}
}

console.log(`node ${spawnArgs.join(' ')}`)

//force colored output, chalk reads it I guess
process.env.FORCE_COLOR = true
const jest = spawn('node', spawnArgs)

function ondata(e, d) {
    const data = d.toString()
    console.log(data)

    if(/Debugger listening on/.test(data)) {
        //source https://github.com/ChromeDevTools/debugger-protocol-viewer/blob/33bdf34ea60c35c483261f398265a821f2e2c4f3/pages/index.md
        openChromeOnDebuggerUrl(Number(inspectBrk.split('=')[1]) || 9229)
    }

    if(/Waiting for the debugger to disconnect/.test(data)) {
        process.exit(0)
    }
}

jest.stdout.on('data', data => ondata('out', data));
jest.stderr.on('data', data => ondata('err', data));
jest.on('close', e => {
    console.log('finished!!')
    process.exit(e)
});
